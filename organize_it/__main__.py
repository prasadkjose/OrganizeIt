# pylint: disable=C0103
""" Main """

import logging
import os
from organize_it.tests._fixtures.directory_structure_fixtures import (
    GENERATED_ROOT_DIR_NAME,
    UNCATEGORIZED_DIR_NAME,
    CATEGORIZED_DIR_NAME,
)

from organize_it.settings import (
    DIR,
    CONFIG,
    WORKING_DIR,
    GENERATED_DESTINATION_TREE,
    GENERATED_SOURCE_TREE,
    GENERATED_SOURCE_JSON,
    TEST_FIXTURES_DIR,
)

from organize_it.cli.input_arg_parser import InputArgParser
from organize_it.bin.file_manager import FileManager
from organize_it.bin.tree_structure import TreeStructure
from organize_it.bin.categorizer import Categorizer
from organize_it.schema_validation.validator import YAMLConfigValidator

logger = logging.getLogger(__name__)


def process_source_and_generate_tree(source_directory, destination_directory):
    """
    Processes a source directory path, generates a hierarchical tree structure of files,
    and generates a trees structure. If the tree structure has already been
    generated previously, it skips the generation process.

    Parameters:
        source_directory (str): The absolute or relative path to the source directory
                                 containing files to be processed.
        destination_directory (str): The path where the generated file tree structure
                                      will be saved.

    Returns:
        tuple: A tuple containing:
            - file_manager (FileManager): An instance of the FileManager class for handling
              file operations in the source and destination directories.
            - tree_structure (TreeStructure): An instance of the TreeStructure class that
              represents the generated file tree.
            - source_tree_dict (dict): A dictionary representation of the file structure in
              the source directory, generated by walking through the source directory recursively.

    Notes:
        - The method may skip tree generation if the tree structure has been previously
          generated, depending on the existence of a specific file or hash check (as indicated
          by the TODO section).

    Example:
        source_dir = "/path/to/source"
        destination_dir = "/path/to/destination"
        file_manager, tree_structure, source_tree_dict = process_source_and_generate_tree(source_dir, destination_dir)
    """

    # TODO: If cli is in interactive mode, then source tree will be will be generated already.
    # So skip this part IF the generated json file exists for a specific run.
    # Could be a hash of the source path or some other parameter like a simple counter interator.
    # Current Structure

    file_manager = FileManager(source_directory, destination_directory)

    # Read the source directory and create oIt tree input dictionary and save it to a file
    source_tree_dict = file_manager.file_walk(None, GENERATED_SOURCE_JSON)

    # write the source tree structure result to a file
    tree_structure = TreeStructure()
    FileManager.create_and_write_file(
        GENERATED_SOURCE_TREE,
        lambda file_stream: tree_structure.generate_tree_structure(
            source_tree_dict, "", file_stream
        ),
    )

    return file_manager, tree_structure, source_tree_dict


def categorize_and_generate_dest_tree(source_tree_dict, tree_structure):
    """
    Categorizes files and directories paths from the source tree dictionary based on a
    given configuration, and then generates and writes the categorized tree structure
    to the destination directory.

    Parameters:
        source_tree_dict (dict): A dictionary representing the hierarchical structure
                                  of files in the source directory, typically generated
                                  from a previous file walk.
        tree_structure (TreeStructure): An instance of the TreeStructure class used
                                         to generate and write the categorized tree structure
                                         to the destination directory.

    Returns:
        dict: A dictionary representing the categorized file tree, where files and
              directories are organized according to the given configuration.

    Example:
        categorized_tree_dict = categorize_and_generate_dest_tree(source_tree_dict, tree_structure)
    """

    # Categorize the files and dirs based on the given config
    categorizer = Categorizer(
        CONFIG
    )  # TODO: this config file path can be provided in interactiv mode too.
    categorized_tree_dict = categorizer.categorize_dict(source_tree_dict, True)

    FileManager.create_and_write_file(
        GENERATED_DESTINATION_TREE,
        lambda file_stream: tree_structure.generate_tree_structure(
            categorized_tree_dict, "", file_stream
        ),
    )

    return categorized_tree_dict


def main():
    """
    The main entry point of the program.

    The function does not take any arguments and does not return a value. Any relevant
    output (such as results, status messages, or errors) is typically printed to the console
    or written to log files.

    This function is typically wrapped in a `if __name__ == "__main__":` block to allow
    for better modularity and to enable unit testing of other parts of the program.
    """
    logger.info(" - Starting to organize...")

    # Validate the YAML config first with the corresponding json-schema
    schema_validator = YAMLConfigValidator(CONFIG)
    schema_validator.validate_config()

    # Take Source and destination as CLI args.
    # Order of preference
    #   1. CLI --src
    #   2. Source from config
    #   3. Current directory
    cli_parser = InputArgParser(
        process_source_and_generate_tree, categorize_and_generate_dest_tree
    )

    if cli_parser.move:
        move_files = cli_parser.move
    else:
        move_files = False

    if cli_parser.src:
        source_directory = cli_parser.src
    elif "source" in CONFIG:
        source_directory = CONFIG.source
    else:
        source_directory = WORKING_DIR

    if cli_parser.dest:
        destination_directory = cli_parser.dest
    elif "destination" in CONFIG:
        destination_directory = CONFIG.destination
    else:
        destination_directory = WORKING_DIR

    ##########################DUMMY###################################################
    destination_directory = os.path.join(
        TEST_FIXTURES_DIR, GENERATED_ROOT_DIR_NAME, CATEGORIZED_DIR_NAME
    )
    source_directory = os.path.join(
        TEST_FIXTURES_DIR, GENERATED_ROOT_DIR_NAME, UNCATEGORIZED_DIR_NAME
    )
    ##########################DUMMY###################################################

    file_manager, tree_structure, source_tree_dict = process_source_and_generate_tree(
        source_directory, destination_directory
    )

    categorized_tree_dict = categorize_and_generate_dest_tree(
        source_tree_dict, tree_structure
    )

    file_manager.categorize_and_sort_file(
        CONFIG,
        categorized_tree_dict[DIR],
        move_files,  # To delete the source files.
    )
    # Explore SYMLINKS(unix), Junction(Windows)


if __name__ == "__main__":
    main()
